<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ROS ナビゲーションメタパッケージのリカバリ動作を自作する | ざきのメモ</title>
<link rel="stylesheet" href="style.css">
<link rel="icon" type="image/png" href="favicon.png">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
</head>
<body>

<header>
<h1>ざきのメモ</h1>
</header>

<article>
<h4>2017/11/28</h4>
<h1>ROS ナビゲーションメタパッケージのリカバリ動作を自作する</h1>

<p>ROS のナビゲーションメタパッケージ（以下、ナビゲーションと呼びます）はロボットが自律移動するためのパッケージです。<br>
ナビゲーションは自己位置推定がうまくいかないときに、リカバリ動作を行います。<br>
このページでは、リカバリ動作を自作する方法を紹介します。</p>
                                  
<h2>環境</h2>
<li>Ubuntu 16.04</li>
<li>ROS Kinetic</li>

<h2>手順</h2>
<h3>1, ROSパッケージを作る</h3>
<p>ナビゲーションはメタパッケージなので複数のROSパッケージから構成されています。<br>
リカバリ動作もまたROSパッケージ単位で管理されることがほとんどです。<br>
なので、まず自作するリカバリ動作用のROSパッケージを作成します。<br>
今回は、go_forward_recovery という名前で直進するリカバリ動作を作っていきます。</p>
<pre class="prettyprint"><code>$ roscd ../src/navigation</code></pre>
<p>依存関係にはとりあえず roscpp を入れておきます。</p>
<pre class="prettyprint"><code>$ catkin_create_pkg go_forward_recovery roscpp</code></pre>
<p>はじめに、CMakeLists.txt を書き変えていきましょう。</p>
<pre class="prettyprint"><code>$ cd go_forward_recovery
$ vim CMakeLists.txt</code></pre>
<pre class="prettyprint"><code>cmake_minimum_required(VERSION 2.8.3)
project(go_forward_recovery)

find_package(catkin REQUIRED
        COMPONENTS
            cmake_modules
            roscpp
            tf
            costmap_2d
            nav_core
            pluginlib
            base_local_planner
        )

find_package(Eigen REQUIRED)
include_directories(
    include
    ${catkin_INCLUDE_DIRS}
    ${EIGEN_INCLUDE_DIRS}
)
add_definitions(${EIGEN_DEFINITIONS})

catkin_package(
    INCLUDE_DIRS include
    LIBRARIES go_forward_recovery
    CATKIN_DEPENDS
        roscpp
        pluginlib
)

add_library(go_forward_recovery src/go_forward_recovery.cpp)
target_link_libraries(go_forward_recovery ${catkin_LIBRARIES})

install(TARGETS go_forward_recovery
       ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
       LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
       )

install(FILES recovery_plugin.xml
    DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
)</code></pre>
<p>次に package.xml を書き換えましょう。</p>
<pre class="prettyprint"><code>$ vim package.xml</code></pre>
<pre class="prettyprint"><code>&lt;package&gt;
    &lt;name&gt;go_forward_recovery&lt;/name&gt;
    &lt;version&gt;1.12.13&lt;/version&gt;
    &lt;description&gt;

       *The description of recovery behavior. 

    &lt;/description&gt;
    &lt;author&gt;Eitan Marder-Eppstein&lt;/author&gt;
    &lt;author&gt;contradict@gmail.com&lt;/author&gt;
    &lt;author&gt;*your name&lt;/author&gt;
    &lt;maintainer email="*your e-mail address"&gt;*your name&lt;/maintainer&gt;
    &lt;license&gt;MIT&lt;/license&gt;
    &lt;url&gt;&lt;/url&gt;

    &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;

    &lt;build_depend&gt;cmake_modules&lt;/build_depend&gt;
    &lt;build_depend&gt;roscpp&lt;/build_depend&gt;
    &lt;build_depend&gt;tf&lt;/build_depend&gt;
    &lt;build_depend&gt;costmap_2d&lt;/build_depend&gt;
    &lt;build_depend&gt;nav_core&lt;/build_depend&gt;
    &lt;build_depend&gt;pluginlib&lt;/build_depend&gt;
    &lt;build_depend&gt;eigen&lt;/build_depend&gt;
    &lt;build_depend&gt;base_local_planner&lt;/build_depend&gt;

    &lt;run_depend&gt;roscpp&lt;/run_depend&gt;
    &lt;run_depend&gt;tf&lt;/run_depend&gt;
    &lt;run_depend&gt;costmap_2d&lt;/run_depend&gt;
    &lt;run_depend&gt;nav_core&lt;/run_depend&gt;
    &lt;run_depend&gt;pluginlib&lt;/run_depend&gt;
    &lt;run_depend&gt;eigen&lt;/run_depend&gt;


    &lt;export&gt;
        &lt;nav_core plugin="${prefix}/recovery_plugin.xml" /&gt;
    &lt;/export&gt;

&lt;/package&gt;</code></pre>
<p>*印がついているものはそれぞれ書き入れてみて下さい。<br>上からパッケージの概要, 著者の名前, 管理者のメールアドレスと名前を意味しています。</p>
<h3>2, recovery_plugin.xml を書く</h3>
<p>ナビゲーションではリカバリ動作をプラグインとして管理しています。<br>ここでは新たにリカバリ動作のプラグインを設定するための recovery_plugin.xml を書きます。</p>
<pre class="prettyprint"><code>$ vim recovery_plugin.xml</code></pre>
<pre class="prettyprint"><code>&lt;library path="lib/libgo_forward_recovery"&gt;
  &lt;class name="go_forward_recovery/GoForwardRecovery" type="go_forward_recovery::GoForwardRecovery" base_class_type="nav_core::RecoveryBehavior"&gt;
    &lt;description&gt;
      A recovery behavior that go straight along the wall.
    &lt;/description&gt;
  &lt;/class&gt;
&lt;/library&gt;</code></pre>
<p>このファイルにもリカバリ動作の概要を書く部分があるのですが、ここは書いておきました。自分で作りたいリカバリ動作に合わせて書き換えて下さい。<br>あと、少しだけ補足をしておくと、move_base では nav_core でリカバリ動作のプラグインを管理しているため、上記のようにクラスを定義します。</p>
<h3>3, リカバリ動作のコードを書く</h3>
<p>ここでやっとリカバリ動作についてコードを書きます！<br>今回は C++ で書いていきます。<br>まずはヘッダーファイルを書いていきましょう。<br>以下のようにディレクトリを作り、その中にヘッダーファイルを書きます。</p>
<pre class="prettyprint"><code>$ mkdir -p include/go_forward_recovery
$ vim include/go_forward_recovery/go_forward_recovery.h</code></pre>
<pre class="prettyprint"><code>#ifndef GO_FORWARD_RECOVERY_H_
#define GO_FORWARD_RECOVERY_H_
#include &lt;nav_core/recovery_behavior.h&gt;
#include &lt;costmap_2d/costmap_2d_ros.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;base_local_planner/costmap_model.h&gt;
#include &lt;geometry_msgs/Twist.h&gt;
#include &lt;geometry_msgs/Point.h&gt;
#include &lt;angles/angles.h&gt;
#include &lt;sensor_msgs/LaserScan.h&gt;

#define RANGE_MAX 5.6

namespace go_forward_recovery{
  class GoForwardRecovery : public nav_core::RecoveryBehavior {
    public:
      GoForwardRecovery();

      void initialize(std::string name, tf::TransformListener* tf, 
          costmap_2d::Costmap2DROS* global_costmap, costmap_2d::Costmap2DROS* local_costmap);

      void runBehavior();

      ~GoForwardRecovery();

    private:
      costmap_2d::Costmap2DROS* global_costmap_, *local_costmap_;
      costmap_2d::Costmap2D costmap_;
      std::string name_;
      tf::TransformListener* tf_;
      ros::NodeHandle n;
      ros::Publisher vel_pub;
      ros::Subscriber scan_sub;
      geometry_msgs::Twist cmd_vel;
      bool initialized_;
      base_local_planner::CostmapModel* world_model_;
      double null_check(double target);
      void scanCallback(const sensor_msgs::LaserScan::ConstPtr&amp; msg);
      int sub_n, sub_flag;
  };
};
#endif</code></pre>
<p>次にいよいよメインのコードを書いていきます。<br>ヘッダーファイルを書いた時に気がついたかもしれませんが、今回は実用的なパッケージの作成を目指しサブスクライバとパブリッシャをリカバリ動作に仕込みます。<br>先ほどと同様に、以下のようにディレクトリを作り、その中にコードを書きます。</p>
<pre class="prettyprint"><code>$ mkdir src
$ vim src/go_forward_recovery.cpp</code></pre>
<pre class="prettyprint"><code>#include &lt;go_forward_recovery/go_forward_recovery.h&gt;
#include &lt;pluginlib/class_list_macros.h&gt;

//register this planner as a RecoveryBehavior plugin
PLUGINLIB_DECLARE_CLASS(go_forward_recovery, GoForwardRecovery, go_forward_recovery::GoForwardRecovery, nav_core::RecoveryBehavior)

namespace go_forward_recovery {
GoForwardRecovery::GoForwardRecovery(): global_costmap_(NULL), local_costmap_(NULL), 
  tf_(NULL), initialized_(false), world_model_(NULL) {} 

void GoForwardRecovery::initialize(std::string name, tf::TransformListener* tf,
    costmap_2d::Costmap2DROS* global_costmap, costmap_2d::Costmap2DROS* local_costmap){
  if(!initialized_){
    name_ = name;
    tf_ = tf;
    global_costmap_ = global_costmap;
    local_costmap_ = local_costmap;
    world_model_ = new base_local_planner::CostmapModel(*local_costmap_-&gt;getCostmap());
    initialized_ = true;
  }else{
    ROS_ERROR("You should not call initialize twice on this object, doing nothing");
  }
}

GoForwardRecovery::~GoForwardRecovery(){
  delete world_model_;
}

double GoForwardRecovery::null_check(double target){
  if(!(target &gt; 0)){
    target = (double)RANGE_MAX;
    //ROS_WARN("RANGE OVER");
  }
  return target;
}

void GoForwardRecovery::scanCallback(const sensor_msgs::LaserScan::ConstPtr&amp; msg){
  double center_number = (-msg-&gt;angle_min)/msg-&gt;angle_increment;
  double center = msg-&gt;ranges[center_number];
  double left = msg-&gt;ranges[center_number+255];
  double right = msg-&gt;ranges[center_number-255];

  center = null_check(center);
  left = null_check(left);
  right = null_check(right);

  //ROS_INFO("center: [%lf], left: [%lf], right: [%lf]", center, left, right);
  //ROS_INFO("center number: [%lf]", (-msg-&gt;angle_min)/msg-&gt;angle_increment);

  if(center &lt; 0.5){
    ROS_WARN("center warning!!");
    cmd_vel.linear.x = 0.0;
    cmd_vel.linear.y = 0.0;
    cmd_vel.angular.z = 1.0;
  }
  if(left &lt; 0.4){
    ROS_WARN("left warning!!");
    cmd_vel.linear.x = 0.0;
    cmd_vel.linear.y = 0.0;
    cmd_vel.angular.z = -1.0;
  }
  if(right &lt; 0.4){
    ROS_WARN("right warning!!");
    cmd_vel.linear.x = 0.0;
    cmd_vel.linear.y = 0.0;
    cmd_vel.angular.z = 1.0;
  }
  if(center &gt;=0.5 &amp;&amp; left &gt;= 0.4 &amp;&amp; right &gt;= 0.4){
    cmd_vel.linear.x = 0.2;
    cmd_vel.linear.y = 0.0;
    cmd_vel.angular.z = 0.0;
  }

  //ROS_INFO("x: %lf, y: %lf, z: %lf", cmd_vel.linear.x, cmd_vel.linear.y, cmd_vel.angular.z);
  vel_pub.publish(cmd_vel);
  ROS_INFO("sub_n: %d", sub_n);
  sub_n++;
  if(sub_n &gt; 300){
    scan_sub.shutdown();
    sub_flag = 0;
    return;
  }
}

void GoForwardRecovery::runBehavior(){
  if(!initialized_){
    ROS_ERROR("This object must be initialized before runBehavior is called");
    return;
  }

  ROS_WARN("Go forward recovery behavior started.");
  sub_n = 0;
  sub_flag = 1;
  scan_sub = n.subscribe("scan", 10, &amp;GoForwardRecovery::scanCallback, this);
  vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;("cmd_vel", 10);
  while(n.ok()){
    if(sub_flag == 0){
      return;
    }
  }
}
};</code></pre>
<p>またこの章では、ライセンスの記述を省いています。以下のパッケージからソースコードを参照して下さい。</p>
<li><a href="https://github.com/zaki0929/navigation/tree/mydev/go_forward_recovery">GitHub - zaki0929/navigation/go_forward_recovery/ </a></li>
<li><a href="https://github.com/ros-planning/navigation/tree/kinetic-devel/rotate_recovery">GitHub - ros-planning/navigation/rotate_recovery/ </a></li>
<pre class="prettyprint"><code>$ </code></pre>


<li><a href="index.html">トップへもどる</a></li>
</article>

<footer>
<small>Copyright &copy; Ryo Okazaki, all rights reserved.</small>
</footer>

</body>
</html>
